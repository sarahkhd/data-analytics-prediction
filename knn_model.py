# -*- coding: utf-8 -*-
"""KNN model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mHDMvPa5C8CG0utlRk8BCT138Cf34q79
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.feature_selection import mutual_info_classif
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

# Load train and test datasets
train_data = pd.read_csv("trainset.csv")
test_data = pd.read_csv("testset.csv")

print("Train Data Summary:")
print(train_data.describe())
print("\nTest Data Summary:")
print(test_data.describe())

# Subset the training data to balance classes
train_index = train_data[train_data["Subscribed"] == 'no'].index
delete_index = np.random.choice(train_index, size=len(train_index) - 22000, replace=False)
train_data_subset = train_data.drop(delete_index)
print("\nTrain Data Subset Summary:")
print(train_data_subset.describe())

#Remove duplicate data in traindata
print("No of data prior to removal:")
print(len(train_data_subset))
train_data_nodup=train_data.drop_duplicates()
print("No of data after removal:")
print(len(train_data_nodup))

train_data['Subscribed'] = train_data['Subscribed'].map({'yes': 1, 'no': 0})

X_train_subset = train_data_subset.drop("Subscribed", axis=1)
y_train_subset = train_data_subset["Subscribed"]

categorical_columns = train_data.select_dtypes(include=['object']).columns

# Create a ColumnTransformer for preprocessing
preprocessor = ColumnTransformer(
    transformers=[
        ('job', OneHotEncoder(), categorical_columns)
    ],
    remainder='passthrough'
)

# One-hot encode categorical columns
encoder = OneHotEncoder()
X_train_encoded = pd.DataFrame(encoder.fit_transform(train_data[categorical_columns]).toarray(),
                                columns=encoder.get_feature_names_out(categorical_columns),
                                index=train_data.index)

# Concatenate one-hot encoded features with the remaining features
X_train_final = pd.concat([X_train_encoded, train_data_subset.drop(categorical_columns, axis=1)], axis=1)

y_train_numeric = y_train_subset.map({'yes': 1, 'no': 0})

X_train_subset = train_data_subset.drop("Subscribed", axis=1)
y_train_subset = train_data_subset["Subscribed"]

y_train_numeric

y_train_numeric = y_train_subset.map({'yes': 1, 'no': 0})

# Separate features and target variable
X_train_subset = train_data_subset.drop("Subscribed", axis=1)
y_train_subset = train_data_subset["Subscribed"]

# Identify categorical columns
categorical_columns = X_train_subset.select_dtypes(include=['object']).columns

# One-hot encode categorical columns
encoder = OneHotEncoder()
X_train_encoded = pd.DataFrame(encoder.fit_transform(X_train_subset[categorical_columns].astype(str)).toarray(),
                                columns=encoder.get_feature_names_out(categorical_columns),
                                index=X_train_subset.index)

# Concatenate one-hot encoded features with the remaining features
X_train_final = pd.concat([X_train_encoded, X_train_subset.drop(categorical_columns, axis=1)], axis=1)

# Convert the target variable to numeric
y_train_numeric = y_train_subset.map({'yes': 1, 'no': 0})

# Calculate mutual information scores
mutual_info_scores_train = mutual_info_classif(X_train_final, y_train_numeric)

# Create a bar plot of mutual information scores
feature_names_train = X_train_final.columns
plt.bar(feature_names_train, mutual_info_scores_train)
plt.xlabel('Features')
plt.ylabel('Mutual Information Score')
plt.title('Mutual Information Scores for Features (Train Data Subset)')
plt.xticks(rotation=45, ha="right")
plt.show()

# Preprocess and scale the training and testing data
def preprocess_data(data):
    data['month'] = pd.to_numeric(pd.Categorical(data['month'],
                                                  categories=['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'],
                                                  ordered=True).codes) + 1
    data['contact'] = pd.to_numeric(pd.Categorical(data['contact'],
                                                    categories=['cellular', 'telephone'],
                                                    ordered=True).codes) + 1
    data.iloc[:, :-1] = StandardScaler().fit_transform(data.iloc[:, :-1])
    return data

new_train = train_data_subset.copy()
print("\nNew Train Summary:")
print(new_train.describe())

training_data = preprocess_data(new_train[['age', 'contact', 'nr.employed', 'month']])
train_data_target = new_train['Subscribed']

testing_data = preprocess_data(test_data[['age', 'contact', 'nr.employed', 'month']])
test_data_target = test_data['Subscribed']

# k-NN Model
knn_model = KNeighborsClassifier(n_neighbors=5)
knn_model.fit(training_data, train_data_target)
knn_pred = knn_model.predict(testing_data)
label_mapping = {'yes': 1, 'no': 0}
test_target = np.vectorize(label_mapping.get)(test_data_target)
label_mapping = {'yes': 1, 'no': 0}

print("Length of knn_pred:", len(knn_pred))
print("Content of knn_pred:", knn_pred)

print("Predictions made by KNN model:", knn_pred)

print(test_data_target)

# Assuming 'test_data_target' is a pandas Series with string labels
# Convert 'yes' to 1 and 'no' to 0
test_data_target_numeric = test_data_target.map({'yes': 1, 'no': 0})

print(test_data_target_numeric)
print(len(test_data_target_numeric))

knn_pred_numeric = np.where(knn_pred == 'yes', 1, 0)

knn_pred_numeric

# Debug prints
print("Number of samples in test_data_target:", len(test_data_target_numeric))
print("Number of samples in knn_pred_numeric:", len(knn_pred_numeric))

# Create the confusion matrix
conf_matrix = confusion_matrix(test_data_target_numeric, knn_pred_numeric)
print("\nConfusion Matrix:")
print(conf_matrix)

print(classification_report(test_data_target_numeric, knn_pred_numeric))